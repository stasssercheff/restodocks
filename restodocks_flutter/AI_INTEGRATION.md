# Интеграция ИИ/нейросетей в Restodocks

План подключения пяти функций: генерация чеклиста, распознавание чека, ТТК из фото/Excel, распознавание продукта, улучшение КБЖУ.

**Важно:** все функции ИИ работают **в рамках платформы** — результат сразу создаёт или правит сущности (чеклист, строки инвентаря, ТТК, продукт, КБЖУ), а не просто отвечает в диалоге. Пользователь нажимает кнопку в интерфейсе → запрос уходит в Edge Function → ответ подставляется в форму/таблицу, после чего можно сохранить или отредактировать.

---

## 1. Генерация чеклиста по запросу

**Что нужно:** Пользователь вводит запрос (например: «утренний чеклист кухни на понедельник»), ИИ возвращает название чеклиста и список пунктов.

**Где в коде:**
- `lib/screens/checklists_screen.dart` — кнопка «Создать по запросу» / «Сгенерировать».
- `lib/screens/checklist_edit_screen.dart` — альтернативно: поле «Опишите чеклист» при создании нового.
- Сервис: `AiService.generateChecklistFromPrompt(String prompt)` → `GeneratedChecklist?`.

**Реализация:** Вызов LLM (OpenAI, Yandex GPT, Claude). Промпт: «По запросу пользователя сгенерируй чеклист для ресторана: название и список пунктов. Запрос: {prompt}. Ответ: JSON с полями name и items (массив строк).»

**Ключи/конфиг:** API-ключ LLM в Supabase Vault или в переменных окружения (backend/Edge Function), не в приложении.

---

## 2. Распознавание чека (фото)

**Что нужно:** Загрузка фото чека → извлечение позиций (название, количество, единица, при необходимости цена) → подстановка в бланк инвентаризации или в «приход».

**Где в коде:**
- `lib/screens/inventory_screen.dart` — кнопка «Загрузить чек» / «Сфотографировать».
- Сервис: `AiService.recognizeReceipt(Uint8List imageBytes)` → `ReceiptRecognitionResult?`.
- После распознавания: создание/дополнение строк в бланке или отдельный экран «Импорт из чека» с возможностью править и применить.

**Реализация:** OCR (Google Vision, Yandex Vision, или Tesseract на backend). Опционально LLM для структурирования сырого текста в список позиций.

**Ключи/конфиг:** API ключ Vision/OCR; вызов лучше делать через Supabase Edge Function или отдельный backend, чтобы не светить ключ в приложении.

---

## 3. Составление ТТК при загрузке фото карточки или Excel

**Что нужно:**
- **Фото карточки:** фото ТТК (не блюда) → OCR → разбор в поля: название блюда, состав, технология, граммы и т.д.
- **Excel:** загрузка файла с листом «ТТК» или похожей структурой → парсинг строк (название, продукты, брутто/нетто, технология) → создание/черновик ТТК.

**Где в коде:**
- `lib/screens/tech_cards_list_screen.dart` или `tech_card_edit_screen.dart` — «Создать из фото» / «Создать из Excel».
- Сервис:
  - `AiService.recognizeTechCardFromImage(Uint8List imageBytes)` → `TechCardRecognitionResult?`
  - `AiService.parseTechCardFromExcel(Uint8List xlsxBytes)` → `TechCardRecognitionResult?`
- Результат подставляется в форму создания/редактирования ТТК (`TechCardEditScreen`), пользователь правит и сохраняет.

**Реализация:**
- Фото: OCR (тот же Vision/OCR) + LLM для извлечения структуры: «Из текста извлеки: название блюда, список ингредиентов (название, брутто в г), технология приготовления. Ответ: JSON.»
- Excel: парсинг через `excel` (уже в проекте), маппинг колонок на модель ТТК; при неочевидной структуре — LLM по тексту ячеек.

**Ключи/конфиг:** OCR + при необходимости LLM; Edge Function или backend.

---

## 4. Распознавание продукта при добавлении вручную

**Что нужно:** При ручном вводе названия продукта — «понимание», что это за продукт: нормализованное название, категория, единица измерения. Это улучшит подбор КБЖУ и поиск в номенклатуре.

**Где в коде:**
- `lib/screens/products_screen.dart` — при добавлении продукта из текста / по одному (после ввода названия или перед сохранением).
- Сервис: `AiService.recognizeProduct(String userInput)` → `ProductRecognitionResult?` (normalizedName, suggestedCategory, suggestedUnit).
- После ответа: подстановка в поля «Название», «Категория», «Единица»; вызов обновлённого КБЖУ-сервиса по нормализованному названию.

**Реализация:** LLM с промптом: «Пользователь ввёл название продукта для ресторана: "{input}". Верни JSON: normalizedName (нормализованное название), category (одно слово: vegetables, meat, dairy, …), unit (g, kg, pcs, …).» Либо NER/классификатор на backend.

**Ключи/конфиг:** LLM API в backend/Edge Function.

---

## 5. Корректный расчёт КБЖУ

**Что нужно:** Более точное или надёжное КБЖУ для продуктов (особенно когда Open Food Facts не находит или даёт странные значения).

**Где в коде:**
- `lib/services/nutrition_api_service.dart` — основной источник по-прежнему Open Food Facts.
- Дополнительно: вызов `AiService.refineOrGetNutrition(String productName, NutritionResult? existing)` → `NutritionResult?` как fallback или уточнение.
- В местах, где вызывается `NutritionApiService.fetchNutrition` (продукты, ТТК, ингредиенты), при отсутствии или сомнительном результате — опционально запрос к ИИ.

**Реализация:**
- Вариант A: LLM по запросу «Для продукта "{name}" укажи КБЖУ на 100 г (ккал, белки, жиры, углеводы). Только числа, JSON.»
- Вариант B: второй внешний API (например, база Минздрава или другая) + эвристики.
- Сохранять приоритет Open Food Facts, ИИ — только подстановка или проверка «адекватности» (диапазоны калорий уже есть в `_maxSaneKcal` и т.п.).

**Ключи/конфиг:** LLM или второй API в backend.

---

## Общая архитектура

- **Клиент (Flutter):** вызывает только свои backend endpoints (Supabase Edge Functions или отдельный сервер). API-ключи ИИ/OCR не хранятся в приложении.
- **Backend (Edge Functions / Node/Python):** OCR, LLM, парсинг Excel (если тяжёлый), возврат JSON. Flutter получает готовые структуры.
- **Сервис в приложении:** `AiService` (или разбить на `ChecklistAiService`, `ReceiptOcrService`, `TechCardImportService`, `ProductRecognitionService`, `NutritionRefinementService`) — только HTTP-запросы к своим endpoints и маппинг ответов в модели приложения.

Текущий `lib/services/ai_service.dart` задаёт интерфейс и заглушки; реальные вызовы подставляются при появлении backend/ключей.

---

## Очерёдность внедрения

1. **Инфраструктура:** Edge Function (или другой backend) с одним LLM endpoint; в приложении — вызов и разбор ответа.
2. **Генерация чеклиста** — один промпт, быстрый эффект.
3. **Распознавание продукта + улучшение КБЖУ** — один LLM, две точки использования (продукты и нутриция).
4. **ТТК из Excel** — без фото, только парсинг; потом добавить ТТК из фото (OCR + LLM).
5. **Распознавание чека** — отдельный endpoint (OCR + при необходимости LLM), затем UI в инвентаризации.

После каждого шага — тесты на реальных данных и при необходимости донастройка промптов и полей.
